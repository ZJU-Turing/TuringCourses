# 数据结构基础

<div class="badges">
<span class="badge cs-badge">CS 专业基础</span>
<span class="badge ai-badge">AI 专业基础</span>
<span class="badge is-badge">IS 专业基础</span>
</div>

## 课程学习内容

FDS 按专题授课，主要介绍栈、队列、树、堆、并查集、图等数据结构，以及最短路、搜索、网络流、排序、哈希等算法。求各专题之间联系不大，不存在前一节课不听后一节课就听不懂的情况。课程难度适中，课程要求主要是掌握简单算法的算法流程（会手算具体样例、会写代码实现），对于一些相对复杂的算法（比如网络流、Tarjan 算法）以及复杂度和定理的证明点到为止，一般只在作业中要求，不会出现在考试中。

以下有两个版本的课程内容大纲，自测版的部分条目以问题的形式出现，答案在完整版里。该大纲可以用于开课前的自测，明确自身定位，以便制定学习计划；也可以用于考前复习。在浏览大纲的同时，可以标记自己不明确的定义以及不清楚的算法，在上课期间重点关照；而如果你对整个专题都非常熟悉，则可以考虑只看 ppt 不听课，用这节课时间做点别的事情。

??? note "课程内容大纲（自测版）"

    1. 第一节课介绍分数构成、作业形式等重要内容！
    2. 复杂度分析
        - 大 O、大 Ω、大 θ、小 o
    2. 栈和队列
        - 中缀表达式转后缀表达式
        - 中缀表达式转前缀表达式
        - 表达式树
    3. 树
        - 前、中、后序遍历
        - threaded binary tree 线索二叉树
        - 完全二叉树、满二叉树
    4. 二叉搜索树
        - 查找、插入
        - 删除根节点
        - 支持删除指定节点(带 lazy tag 后的查找和删除)
    5. 堆
        - 线性建堆及其复杂度证明
        - push & pop
        - d-heap（满足堆性质的 d 叉树）: 
            - push & pop 复杂度
            - 父亲编号、最大的儿子编号、最小的儿子编号
    7. 并查集
        - union-by-size 及其复杂度证明
        - union-by-depth 及其复杂度证明
        - 路径压缩
    8. 图
    9. 最短路算法
        1. Floyd
        2. Dijkstra
            - 堆优化
            - 可以处理负权边吗？
        3. Bellman-Ford & SPFA
        4. 拓扑排序
    10. 其他图论算法
        1. 最小生成树
            - Kruskal
            - Prim
        2. 最大流
            - 最大流最小割定理，平面图最大流的对偶图方法，及其局限性（课程不涉及，但可以加快手算最大流的速度）
            - 增广路算法：
                1. 什么是反向边？
                2. Dinic & 当前弧优化
    11. DFS 的应用：
        1. 欧拉路径（回路）和哈密尔顿路径
        2. **无向图**的双连通分量
            - 定义（一个关节点可以出现在多个双连通分量中吗？）
            - tarjan 算法
        3. **有向图**的强联通分量
            - tarjan 算法
    12. 排序：
        - 插入排序
        - 希尔排序
        - 堆排序
        - 快速排序
        - 归并排序
        - table sort
        - bucket sort（桶排序） & radix sort（基数排序）
        - 其他
            - 稳定的排序
            - 基于交换的排序的复杂度下界证明
    13. Hash
        - 哈希函数：自变量是整数的情况，自变量是字符串的情况
        - 开放寻址法
            1. linear probing 循环找下一个位置直到找到空位
            2. quadratic probing: 往后找 1, 2, 4, ... 个位置
            3. double hashing: `f(i)=i*hash2(x)` 探测的步长与 key 值有关
            4. rehashing
        4. seperate chaining: 对相同哈希值用链表存储
        - 删除（tag）

??? note "课程内容大纲（完整版）"

    1. 第一节课介绍分数构成、作业形式等重要内容！
    2. 复杂度分析
        - 大 O：上限（ **logN is O(N)**，大 O 只规定上限，这句话是对的 ）
        - 大 Ω：下限
        - 大 θ：上限 + 下限
        - 小 o：无穷小量（大 O 的反向操作）
        - **if/else：选较大的那个分支算大 O 复杂度**
    2. 栈和队列
        - 中缀表达式转后缀表达式
            1. 如果是操作数, 则直接压进**输出队列**中
            2. 如果是运算符, 分以下情况:
                a. 运算符堆栈为空, 或者**运算符栈**顶元素为'(', 则直接将运算符压进栈
                b. 运算符如果是')', 则将运算符栈中的元素都压进去输出队列中并将其弹出运算符栈, 直到遇到'('为止
                c. 运算操作符是'+' '-' '*' '/' 之一的时候, 将其与运算符栈顶元素作比较,如果栈顶的优先级较小（ **如果运算符是左结合的则优先级相等也要出栈** ）, 则将运算符压入栈中。否则, 将栈顶元素弹出并压入输出队列中, 然后继续比较栈顶, 直到运算符被压入栈.
        - 中缀表达式转前缀表达式
            1. 存两个堆栈, 一个存放操作数, 一个存放运算符
            2. 由于要转换为prefix, 运算符在操作数前, 所以扫描从中缀表达式 **从右往左** 扫描.
            3. 如果是操作数, 则直接压进操作数栈中
            4. 如果是运算符, 分以下情况:
                a. 运算符堆栈为空, 或者运算符栈顶元素为')', 则直接将运算符压进栈
                b. 运算符如果是'(', 则将运算符栈中的元素都压进去操作数栈中并将其弹出运算符栈, 直到遇到')'为止
                c. 运算操作符是'+' '-' '*' '/' 之一的时候, 将其与运算符栈顶元素作比较,如果栈顶的优先级较小,（ **如果运算符是右结合的则优先级相等也要出栈** ） 则将运算符压入栈中. 否则, 将栈顶元素弹出并压入操作数栈中, 然后继续比较栈顶, 直到运算符被压入栈。
            5. 扫描完一遍后, 将运算符堆栈剩余的元素都压入操作数栈中。
            6. 将操作数栈从栈顶到栈底输出就是prefix.
            - 前缀表达式的计算：从前往后读，把遇到的运算符放到运算符栈，遇到的数字放到数字栈，一旦数字有两个就拿出来用运算符栈顶的运算符计算，把结果放回数字栈。
        - 表达式树(expression tree)：后缀表达式是表达式树的后序遍历，前缀表达式是表达式树的前序遍历。
    3. 树
        - traversal:（名字容易记错）
            - 前序遍历(**preorder**): 根左右
            - 中序遍历(**inorder**): 左根右
            - 后序遍历(**postorder**): 左右根
        - **degree of tree: max degree of node; degree of node on tree: 节点拥有的儿子个数（父亲不算），概念很容易忘**
        - 任意树变成二叉树：倾斜 45 度，兄弟变儿子；i.e.左儿子是第一个儿子，右儿子是兄弟
        - threaded binary tree 线索二叉树
            - 目的：n 节点二叉树有 n+1 个儿子指针是 NULL，利用这些指针来使遍历更加方便
            - **分类**：前序 / 中序 / 后序 threaded binary tree
            - 构造：NULL 的左儿子换成（前序 / 中序 / 后序）遍历中的前驱节点，右儿子换成后继。
            - 遍历：不再需要回溯，只需要判断自身和左右儿子的顺序即可
        - 完全二叉树、满二叉树
    4. 二叉搜索树: 参考 [这个博客](https://zhuanlan.zhihu.com/p/99949110) 或者随便搜一个博客看
        - 查找、插入
        - 删除根节点
        - 支持删除指定节点(带 lazy tag 后的查找和删除)
    5. 堆
        - property：
            - 每个节点都比儿子大（左右儿子之间没有限制）
            - 一定是 complete binary tree
            - 查找只能 $O(N)$
            - 编号从 $\lfloor \frac{N}{2}\rfloor +1$ 开始就都没有儿子
        - operation
            - **线性建堆**(linear xxx)：保证操作每个节点时，他的两个儿子子树都是堆，然后将这个节点往下推。有 $\frac{N}{2}$ 个节点需要往下推至少一次，$\frac{N}{4}$ 个节点往下至少两次，以此类推 $T(N)=\frac{N}{2}+\frac{N}{4}+...=O(N)$
            - push：在最大编号后面插入，依次往上交换
            - pop：**把编号最大的放到根的位置**（否则无法保证完全二叉树的性质），左右儿子挑一个大（小）的提上来
        - d-heaps: 
            - 单次操作 $O(d \log_dN)$，d 为 3 时时间复杂度最低
            - 父亲：$father(i)$ 是一个阶梯函数，$father(1) = 0$，每过 d 个数函数值 +1，$father(i) = \lfloor (i+d-2)/d\rfloor$
            - 最大的儿子：把最大的儿子后面的节点全去掉，则树上除了叶子之外全都是满儿子，$$father(son_{max}(i)) = [son_{max}(i)-1]/d = i$$ 所以 $son_{max}(i)=id+1$
            - 最小的儿子： $son_{min}(i) = (i-1)d+2$
    7. 并查集
        - union-by-size 及其复杂度证明：小树合并做大树的儿子，查询 $O(\log_2 N)$。因为从任意节点每往上爬一层，子树大小至少翻一倍
        - union-by-depth 及其复杂度证明：浅树合并做深树的儿子，查询 $O(\log_2 N)$，因为一棵深度为 n 的树需要 2 棵深度为 n-1 的树合并得到，所以深度为 n 的树大小至少为 $2^n$，树深度为 $O(\log_2 N)$ 级
        - 路径压缩：查询和合并的复杂度都是 $O(1)$，下面是一种非递归写法
            ```c
            SetType  Find ( ElementType  X, DisjointSet  S )
            {
                ElementType  root,  trail,  lead;
                for ( root = X; S[ root ] > 0; root = S[ root ] );
                for ( trail = X; trail != root; trail = lead ) {
                lead = S[ trail ] ;   
                S[ trail ] = root ;   
                }
                return  root ;
            }
            ```
    8. 图
        - tips1: 单讲 connected 一般是无向图，有向图要分强联通和弱联通
        - tips2: 有向图的 adjacent 有 from 和 to 之分
        - 一种图的存储方式：adjacent multilist，就是同一条边存两个next，分别是对于出点的 next 和对于入点的 next，方便找入度
    9. 最短路算法
        1. Floyd $O(N^3)$
        2. Dijkstra $O(V^2+E)$
            - 堆优化：$O((V+E)\log V)$，log 后面是 E 还是 V 并不关键因为 E 最多是 V 的平方。
            - 可以处理负权边吗？不能
        3. Bellman-Ford & SPFA
            - SPFA 平均情况下 $O(kE)$, 其中 $k$ 是所有顶点进队的平均次数，一般满足 $k<2$。最坏情况退化为 Bellman-Ford 算法，复杂度 $O(VE)$
            - 用数组 dis 记录每个结点目前的最短路径值，用邻接表来存储图 G。设立一个队列用来保存待优化的结点，优化时每次取出队首结点 u，并且用 u 点当前的最短路径值对 u 点能到达的所有结点 v 进行松弛操作，如果 v 点的最短路径估计值有所调整，且 v 点不在当前的队列中，就将 v 点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。
        4. 拓扑排序
    10. 其他图论算法
        1. 最小生成树
            0. 性质：边权最小的边一定在最小生成树中（用于证明两个算法的正确性）
            1. **Kruskal**（Kruskal 基于边，Prim 基于点，区分一下）：
                - 做法：按边权从小到大排序 + 取边做并查集
                - 证明：用性质
            2. **Prim**：
                - 做法：以某个点为初始点集，每次选点集和外界连边中最小的边，把那个点加入点集
                - 证明：用性质
        2. 最大流
            1. 定义：有源有汇，其他点流入等于流出。 [定义参考博客](https://blog.csdn.net/mystery_guest/article/details/51910913)
            2. 定理：最大流 = 最小割
                1. 平面图网络流：
                    - 把源汇连边，找 **对偶图** （面作为点，面之间相邻就连 2 条 **有向边**，正向保留边权，反向设为 0，走一条有向边表示把边左边的点放进 s 的集合中，右边的点放进 t 的集合中）
                    - 求最短路（本质上来说对偶图中的环相当于一个割。为了保证源汇在不同的集合中，强制选取了源汇之间连的虚拟边）
            3. 常见增广路算法：
                1. 核心思路： **引入反向边**
                    - 反向边小技巧：正向边存在数组的偶数位，反向边存在奇数位，则取反向边只需要 `i^1`
                2. Ford-Fulkerson：找到增广路径就更新
                3. Edmonds-Karp (EK 算法) ：BFS 找边数最少的增广路径更新，$O(NM^2)$
                4. Dinic：在 EK 的基础上，分层 (BFS) + 多路增广(DFS)，复杂度 $O(N^2M)$
                    - 当前弧优化：已经增广过的边不再增广，引用写法 `for (int &i = cur[u]; i; i = g.nxt[i])`
    11. DFS 的应用：
        1. 欧拉路径（回路）和哈密尔顿路径
            - 欧拉回路 dfs： $O(V+E)$
        2. **无向图**的双连通分量(biconnectivity)
            1. 定义：
                - **articulation point**: 关节点，去掉这个点图变得不连通（注意记名词，并且关节点出现表示这张图一定是无向图）
                - biconnected graph: 不存在关节点
                - biconnected component: maximal biconnected subgraph
            2. tarjan 算法：
                1. 生成一颗 dfs 树，遍历顺序记为 `dfn[v]`
                2. 除了树边之外仅可能存在一种边：连接 u 和 u 子树中的节点 v 的边。记 `low[v]` 为从 **v 和 v 子树中的节点** 出发走 **1 条** 非树边能够到达的最小 dfn，更准确地说，
                
                $$
                low[u]=\min
                \left\{
                \begin{align*}
                &dfn[u]&\\
                &low[v]&,v\textsf{ is a son of }u\\
                &dfn[w]&,(u,w)\textsf{is a back edge}
                \end{align*}
                \right\}
                $$

                当 u 的某个儿子 v `low[v]>=dfn[u]` 时 u 是关节点。
                3. 想要记录每个双联通分量中的点有哪些：将遍历到的点都入栈，在找到关节点的时候不断出栈直到关节点出栈，然后再把关节点入栈。（因为每个关节点可能会被包含在多个点双中）
                4. 注意：对于图的所有不连通的分量都要搜索，注意特判孤立节点的情况
        3. 有向图的强联通分量：
            1. 生成一颗 dfs 树，遍历顺序记为 `dfn[v]`
            2. 除了树边之外可能存在 3 种边：
                1. 前向边：可以忽略
                2. 后向边：可以形成强连通
                3. 横插边：从 dfn 大的子树插到 dfn 小 的子树
            3. `low[u]` 表示 **从 u 出发可以到达的最小的 dfn**（和无向图双联通分量区分），其中 w 必须是还未确定在哪个强连通分量的点（即需要在栈中，用 `inq[w]` 来判断）

            $$
            low[u]=\min
                \left\{
                \begin{align*}
                &dfn[u]&\\
                &low[v]&,v\textsf{ is a son of }u\\
                &low[w]&,(u\to w)\textsf{ is a non-tree-edge and w}\in \textsf{undetermined component}
                \end{align*}
                \right\}
            $$

            4. 当节点 u 满足 `low[u]==dfn[u]` 时说明 u 和他的父亲属于不同的强连通分量，弹栈直到弹出 u
    12. 排序：
        1. 插入排序：
            - 插入排序（以及任何交换相邻元素的排序）的交换次数 = 逆序对个数(inversion count)
            - 最大比较和交换次数 $\frac{n(n-1)}{2}$，最小比较和交换次数 $n-1, 0$
            - stable sort
        2. 希尔排序 Shell Sort：
            - 取步长(也称增量，**increment**)，进行分组插入排序，并逐步缩小步长，直到步长为 1，变为插入排序。
            - 步长可以取 `floor(n/2)`，每次除 2。
            - 平均复杂度取决于步长的选取，在随机条件下效果较好，$O(N^{\frac{3}{2}})$ 或者 $O(N^{\frac{5}{4}})$
            - unstable sort
        3. 堆排序：
            - $O(N)$ 建堆，每次把堆顶的元素和最后一个元素交换，$O(logN)$ 更新堆。理论总复杂度不到 $O(NlogN)$，但实际效果并不好。
        4. 快速排序：
            - 方法：
                1. 首先，在这个序列中随便找一个数作为基准数（只取其值不取其具体元素）
                2. 这里可以用两个变量 i 和 j ，分别指向序列最左边和最右边，称作 “哨兵 i ” 和 “哨兵 j ”
                3. 左边的哨兵向右移动直到找到第一个大于基准数的数，右边的哨兵向左移动直到找到第一个小于基准数的数，交换这两个数
                4. 若 i > j 则说明 j 以及 j 左边都是小于 pivot 的数；i 以及 i 右边都是大于 pivot 的数；i 和 j 中间（不包含 i，j）得数都等于 pivot。所以递归处理 j 的左边和 i 的右边部分（包含i，j）
            - 一些问题：
                1. 如何选择 pivot 值？：
                    - 问题：选择固定值最坏情况复杂度 $O(N^2)$
                    - 解决方法1：随机 pivot，但是生成随机数复杂度较大
                    - 解决方法2：使用头、中间、尾部三个数的中位数作为 pivot
                2. 遇到等于 pivot 交换不交换？：遇到 pivot 直接 pass，等于 pivot 的不进入下一层递归，这样就不会被 `1, 1, ..., 1` 数据卡成 $O(N^2)$
                3. 在 N 较小时（N<20）快速排序的效率不如插入排序：在 N 较小时用插排解决。
            - 复杂度分析： $T(N)=T(i)+T(N-i-1)+cN$，最坏 $O(N^2)$，最好 $O(N\log N)$，平均 $T(N)=\frac{2}{N}\sum_{i=0}^{N-1}T(i) +(N-1)=O(N\log N)$，可用错位相减法求通项。 [参考博客](https://zhuanlan.zhihu.com/p/149596780)
        5. 归并排序：
            1. 从中间分成两段，分别递归
            2. 在临时数组中进行归并，需要 $O(n)$ 的空间
        6. table sort（**名字容易忘**）：用 `table[i]` 表示第 i 大的元素的下标，用于交换复杂度较高的场景
        7. bucket sort（桶排序） & radix sort（基数排序）：
            - **LSD** (Least Significant Digit)：即从最低位开始排序，这样一定是按照低位从小到大的顺序放到高位的桶里，保证排序。
            - **MSD** (Most Significant Digit): 每个 run 之后对每个 bucket 单独排序，所以复杂度会更大一些。
            - 复杂度：$O(N+B)$ & $O(P(N+B))$，其中 B 是基数，P 是重复次数，N 是桶或者基数个数
        8. 其他
            - **stable sort**(易考): 大小相同的元素不会交换位置
            - unstable sort：会交换位置
            - 基于交换的排序的复杂度下界：排序树的深度 $k\geq \log_2(N!)$，又有 $log_2(\frac{N}{2}\log_2 \frac{N}{2}=\frac{N}{2}^{\frac{N}{2}})\leq\log_2(N!)\leq log_2(N^N)=N\log_2N$，所以 $\log_2(N!)=\Theta(N\log N)$
    13. Hash
        0. 专有名词：
            - collision：表项已经存在
            - overflow：表放满了
            - loading density = 已经放了几个数到 hash table 里 / 总共可以放几个（**常见题目：第一次发生冲突时的  loading density**）
            - identifier density = 已经放了几个数到 hash table 里 / 可能放到 table 里的数的总个数
            - Hash Function & **key & hash value** (注意区分) : H(key) = hash value.
        1. 时间复杂度：没有冲突 $O(1)$
        2. 哈希函数：自变量是整数，自变量是字符串（选择部分字符看成 32 进制数）
        3. 开放寻址法 open addressing：
            1. linear probing 循环找下一个位置直到找到空位
                - linear probing 的期望 probe 次数：对于插入或者不成功的查询 $\frac{1}{2}(1+\frac{1}{(1-\lambda)^2})$，对于成功的查询 $\frac{1}{2}(1+\frac{1}{1-\lambda})$
            2. quadratic probing: 往后找 1, 2, 4, ... 个位置
                - 定理：如果使用平方探测，且表的规模是素数，那么当表至少有一半是空的时候，总能插入新的元素。![Alt text](./img/%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95.png)
                - 拓展：如果表的规模是形如 $4k+3$ 的素数，则平方探测法可以探测到整张表。
            3. double hashing: `f(i)=i*hash2(x)` 探测的步长与 key 值有关，解决聚集问题（**double hashing 和 rehashing 的名字容易记混**）
                - 二次哈希函数需要满足的条件：不会映射到 0，能够探测整个表。例如 `hash2(x)=R-(x%R)`，其中 R 是比 tablesize 小的质数（tablesize 也是质数）
            4. rehashing：
                - rehashing 的条件：如果表已经有一半满或达到一定的插入率，或者某次插入失败了
                - 操作：把已经插入的 key 用新的哈希函数插入到一张新的表里，**新表的大小是比当前大小的两倍大的最小质数**，不是直接乘 2，否则非质数的表会导致效率降低。
                - 复杂度：因为之前的插入已经是 O(N) 的了，重新哈希一遍只会给每次插入的时间复杂度加一个常数。但交互的时候重新哈希速度慢会被用户感知。
        4. seperate chaining: 对相同哈希值用链表存储，简单粗暴
        5. 如何删除：先标记删除。频繁删除会降低插入的效率



## 任课教师

=== "朱建科"

    双语教学，但是英语讲的一般，有时含混不清。上课基本是读 ppt，看 ppt 不听课的同学可以完全不用担心上课讲到了 ppt 上没有的内容。

    上课不点名，但小测不会提前通知。如果是线下教学，小测是手写代码上交，也可以在下课前在钉钉拍照上交；如果是线上教学小测在 pta 上进行。

    关于总评成绩，期末考试成绩不能覆盖期中，bonus 可以直接补在总分里。project 助教给分不错，分数基本与报告长度成正比，但方差较小（所以卷报告长度拿分效率不高）。

=== "陈越"
    陈越老师是个比较有个性的老师，导致她查老师的评分比较低，但只要不触碰她的雷区，她其实是个非常好的老师。陈越的规则意识非常强，她提到的纪律就是铁律，要是违反的话她将会按照跟约定好的惩罚措施实行惩罚，所以一定要认真听她讲的规矩，按照规矩办事。下面是一些一定要注意的雷区：
    
    1. 作业的函数题和编程题一定不要网上复制代码！！！！一定不要抄别人的代码！！！！她每次作业都会使用 PTA 的查重功能，以第一次全部通过测试的代码作为查重的指标，一旦你被查重，她将让你去退课等重修，不退课只能挂科！！！非常严重！！！写她的作业一定要记住函数题和编程题一定要自己写！！不要想着拿网上的代码来测试 OJ 有没有错误！！！不要将自己的代码发出去给别人看，免得被抄！！！！
    2. 她规定 project 的互评不能泄露个人信息，否则本次 project 互评为 0 分，project 的注释要为代码的 30%，否则本次互评直接扣 50 分，这两条必须要严格执行，即使你觉得无意义，别的班或许会通融，但是在姥姥的班，一旦发现将按照这规定的惩罚措施执行。
    
    最雷的点也就差不多以上这些，总体来说就是认真听她的规矩，按照规矩办事，一旦出了什么问题，一定要充分利用自己申诉的权利，特别是被误判或者被恶意扒个人信息的时候，这个时候姥姥会给你申诉的机会和空间的。除了这些雷点，陈越老师其实是个非常好的老师，讲课讲的非常好，上课像慈祥的老奶奶，英语非常标准，在较难的地方会用中文来解释，上她的课能学到很多东西。除此之外，她的期中、小测都是在 PTA 上进行，都是作业题，或者跟作业题难度差不多，难度适中，不会有变态的题目，好好做作业这两块的分数都不会差的，她的课有 bonus 能够补平时分，要是 project 选 hard 难度的话相当于你的总分比别人多 5 分，给分也是非常好的。由于评分的关系选上她的课难度不会太高，推荐规则意识比较强的同学选她的课。

=== "何钦铭"
    中文讲课，ppt 英文，讲课内容完全参照 ppt。

    不点名不小测（都不占分数），但是有可能会在课前在 pta 开一套题目作为签到（分数计入作业，但是 21 级只是口头说过，并没有这样搞过）。

    总评成绩 bonus 不溢出，但 hard 多的 5 分总评可以溢出。期末分数占比是最重的（50%），需要认真对待。

=== "杨子祺"
    中文讲课，上课节奏适中，知识点讲解也比较清楚，也会有适当的代码讲解。

    上课不点名，但是需要注意的是 22 级有三次不提前通知的小测，占总评 10 分。每次小测都是一道作业原题，非常简单，并且只要求写答案，不需要过程，因此基本到课了本次小测就是满分。如果错过一次小测，相当于总评丢掉了 3.3 分，非常不值得。而且鉴于 yzq 老师讲课挺不错的，建议没有 fds 基础的同学不要翘课。

## 分数构成

=== "朱建科"
    - 作业 10%：全部在 pta 上布置
    - quiz 10%：2 到 3 次，期中考和期末考前两三周小测概率较大，可能会线下要求手写代码
    - 期中考 15%
    - 期末考 40%
    - lab 25% 或 30%
        - lab 分数 = 助教打分 50% + 互评 50%
        - lab 有 normal 和 hard 两个可选分级，前者 25 分，后者有 30 分。选择 hard 的同学总分是 105 分，超过 100 的分数会被舍掉。
    - bonus 4%：一般可以直接补在总分里，也有可能只能补平时分，视不同老师而定。

=== "陈越"
    - 总体来看，平时分60%，期末40%，细则如下：
    - 作业：10%
    - 课前小测：10%
    - 期中：15%
    - 期末：40%，如果你的期末考的比期中要高，那么期中的分数将会调为期中的分数
    - project：25%(normal) / 30%(hard)，选hard的同学多出25分的部分将直接加在总分中，不算在平时分的60%中
    - bonus：4分，这四分Bonus用于补平时分，平时分补满60分为止。
    - 其他细则：总评超过100分的同学除非你所有分数都是满的，否则一律为99。要是全满，则总评为100。 

=== "何钦铭"
    - 期末 50%
    - 平时分 50%
        - 期中 15%
        - homework 10%
        - project 25%
        - bonus 4%
    
    平均分四个部分加起来和 50 取 min（不溢出），期中 project 分数不论 normal 还是 hard 都是 100 分满。但是选了 hard 的可以在总评上额外多加 <project 分数（100 满）> * 0.05 分。

=== "杨子祺"
    - 期末 40%
    - 平时分 60%
        - 期中 15%：期末成绩可覆盖期中成绩
        - 作业 10%：每周作业在 pta 上布置，题量不大
        - project 
            - normal 25%，hard 30%, hard 多出来的五分可以溢出到总评
        - quiz 10%：22 级总共 3 次 quiz，每次一道题，并且是作业原题，详见任课教师中的评价
        - bonus 4%：bonus 为两道编程题，每道两分，在 pta 上完成，此部分 bonus 只加在平时分上，不能溢出到总评



## 课程教材

官方教材是《Data Structures and Algorithm Analysis in C》，可以在 [zlibrary](https://search.zhelper.net/?[{%22name%22:%22zlib.app%22,%22url%22:%22https://api.zlib.app%22,%22type%22:%22full%22,%22sensitive%22:false,%22detail%22:false,%22download%22:%22https://d.zlib.app/download/%22}]) 上搜索书名进行下载。但教材上课并不会用到，老师一般会基于 ppt 进行讲解。对于不明白的算法，百度或者 google 搜索算法名字，用别人的博客进行学习是一个效率较高的选择。对于课上教授的经典算法和数据结构，网上有非常多全面且细致的博客，一般不需要买其他教材。

## 参考笔记
- xg 的数据结构复习笔记：https://note.tonycrane.cc/cs/algorithm/ds/
- PTA 作业和历年卷上一些易错理论题的整理：https://lhxcs.github.io/note/cs/ds/pta/

## 课程学习建议

在制定 FDS 的学习计划之前，可以先利用上面的大纲进行自测。如果你对大部分数据结构比较熟悉，对大部分算法能够大致说出流程或者知道核心思想（比如快排的哨兵、最大流的反向边），对小部分知识点听说过但是不甚了解，并且对自己的 C 语言功底比较有自信，那么你可以选择只在这门课上花费一周两课时甚至更少的时间。如果你对于每个专题都或多或少有些不了解的地方，并且有些专有名词是第一次看见，那么你需要在这门课上投入更多的时间。

### 对想要为 FDS 投入时间的同学

建议好好听课，或者去听你觉得讲的好的老师的课。

其次，作业非常重要，基本涵盖考试会考到的所有知识点。作业请认真完成并及时订正。另外 FDS 有不少杂乱的小知识点，有一个笔记本记录下自己容易忽视的部分，会大大减轻考前复习的压力，好记性不如烂笔头嘛。

所以每周花费的时间大概是 2 课时听课，2 到 3 课时作业以及 0 到 1 课时的订正整理和其他事项。

如果你觉得仅仅完成课内任务还不够，可以选择刷期中期末真题。

### 对不想为 FDS 花费很多时间的同学

课可以不听，在你预感要小测的时候去教室坐着就行了。但是有两个部分我觉得是有必要保证完成的——作业和整理。

首先是作业。作业基本涵盖考试会考到的所有知识点，甚至有原题或者非常相似的题。做作业和订正是基本盘，需要认真对待。即使你已经非常熟悉某个专题的知识点了，也需要通过作业接触一些毒瘤题，以及筛查一下有没有之前没注意到的知识点。并且对于熟练工而言，每周作业花不了很多时间。

其次是整理。整理的好处毋庸讳言，特别是像 FDS 这样考试分数占比较大的科目，整理能为你的期中期末考提分不少。并且 FDS 知识点较少，并且分专题，所以非常好整理。你可以在考前去看别人的整理，或者跟着课程进度做笔记，或者在期末自己从头梳理一遍。对于不想花太多时间的同学，在开学时就找到一份不错的知识点整理，在此基础上进行修改时效率最高的。

### Project Report 避坑指南

FDS 是同学们第一次接触“互评”的课程。在互评中你的程序和报告会交给三位课友进行打分，而你也需要给三位同学打分。为了保证公平，你需要保证你的程序和报告不泄露个人信息。并且报告的评分标准非常繁杂，建议面向要求编写报告。详细的报告要求会在第一次互评时给出，但当你看到报告要求时报告的提交已经截止了。为了不被严格的互评人背刺，最好提前对互评要求有一定的概念，下面罗列了报告每一章节容易忽视的注意事项（并不全面，详细要求见老师给出的文档）。

0. 删除个人信息（老师会发一个 ppt 专门教怎么删除个人信息）
1. 封面
    - 标题 + 日期 (没写 -1，下面同理)
2. Chapter 1 Introduction
    - 自己描述题目，不能照搬照抄 (-3)
3. Chapter 2 Algorithm Specification
    - 伪代码 + 自然语言描述
    - 不要直接贴项目代码
4. Chapter 3 Testing Result
    - 每一组测试样例都要写 purpose (-3)
    - 至少一组综合测试样例 (comprehensive test case)，数据规模的上下边界各一组，极限情况 (extreme case) 必须测试到，再加 n 组随机数据 (-4，一般不会要求非常严格)
    - 可以搞点图表来展示运行时间
5. Chapter 4 Analysis and Comments
    - 分析复杂度需要写过程不能直接给出结果 (-4)
        - 例如循环的复杂度要这么写：*The loop runs for N times and the complexity of each loop body is O(1), so the total time complexity is O(N).*
    - 时间和空间都要写到
6. 代码
    - 一定要多写注释，至少写到代码总长度的 30% 以上 (-50，某些老师如 cyll 管得比较严)
7. README
    - 怎么编译？怎么运行？怎么输入？期望的输出？最好能给一组样例输入输出
